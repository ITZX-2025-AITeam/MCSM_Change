<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>防御配置 - Qwen智驾分析系统</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; }
        body { background-color: #f6f8fa; min-height: 100vh; padding: 20px; display: flex; justify-content: center; align-items: center; }
        .container { width: 90%; max-width: 800px; background-color: #ffffff; border-radius: 6px; border: 1px solid #e1e4e8; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04); overflow: hidden; }
        header { background: #f6f8fa; color: #24292e; padding: 20px; text-align: center; border-bottom: 1px solid #e1e4e8; }
        h1 { font-size: 1.8rem; margin-bottom: 8px; font-weight: 600; }
        .subtitle { font-size: 0.9rem; color: #6a737d; }
        .subtitle a { color: #0366d6; text-decoration: none; }
        .subtitle a:hover { text-decoration: underline; }
        .content { padding: 20px; }
        .input-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 6px; font-weight: 600; color: #24292e; font-size: 14px; }
        textarea { width: 100%; padding: 8px 12px; background-color: #ffffff; border: 1px solid #d1d5da; border-radius: 6px; font-size: 14px; transition: border-color 0.3s; min-height: 300px; resize: vertical; line-height: 1.6; }
        textarea:focus { border-color: #0366d6; outline: none; box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.1); }
        button { background: #d73a49; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 6px; cursor: pointer; width: 100%; transition: background 0.3s; font-weight: 600; letter-spacing: 0.5px; margin-top: 10px; }
        button:hover { background: #b92534; }
        .status-message { margin-top: 15px; padding: 10px; border-radius: 6px; text-align: center; display: none; }
        .status-message.success { background-color: #e6ffed; color: #22863a; border: 1px solid #b3dfc3; }
        .status-message.error { background-color: #ffeef0; color: #d73a49; border: 1px solid #f9d7db; }
        .description { font-size: 14px; color: #586069; margin-bottom: 15px; padding: 10px; background: #f1f8ff; border-radius: 6px; border: 1px solid #c8e1ff; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>防御规则配置 (Regex Filter)</h1>
            <div class="subtitle">在这里定义用于拦截恶意提示词的正则表达式 (<a href="/">返回主页</a> | <a href="/config">修改提示词</a>)</div>
        </header>
        <div class="content">
            <div class="input-group">
                <label for="rules">正则表达式规则 (每行一条)</label>
                <div class="description">
                    系统在更新提示词前，会用这里的规则进行检查。如果任何一条规则(不区分大小写)匹配成功，更新将被拒绝。
                    例如，规则 "忽略.*指令" 会拦截包含 "忽略先前指令" 等字样的提示词。
                </div>
                <textarea id="rules" placeholder="正在加载当前规则..."></textarea>
            </div>
            <button id="saveBtn">保存并应用新规则</button>
            <div id="statusMessage" class="status-message"></div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const rulesTextarea = document.getElementById('rules');
            const saveBtn = document.getElementById('saveBtn');
            const statusMessage = document.getElementById('statusMessage');

            // 1. 页面加载时获取当前规则
            try {
                const response = await fetch('/get_rules');
                const data = await response.json();
                if (response.ok) {
                    rulesTextarea.value = data.rules.join('\n');
                } else {
                    rulesTextarea.value = '无法加载规则: ' + data.error;
                }
            } catch (error) {
                rulesTextarea.value = '加载规则失败: ' + error.message;
            }

            // 2. 点击保存按钮时提交新规则
            saveBtn.addEventListener('click', async () => {
                // 将文本域内容按行分割成数组
                const newRules = rulesTextarea.value.split('\n').filter(rule => rule.trim() !== '');
                saveBtn.textContent = '正在保存...';
                saveBtn.disabled = true;

                try {
                    const response = await fetch('/set_rules', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ rules: newRules })
                    });
                    const data = await response.json();
                    
                    statusMessage.textContent = data.message || data.error;
                    statusMessage.className = response.ok ? 'status-message success' : 'status-message error';
                    statusMessage.style.display = 'block';

                } catch (error) {
                    statusMessage.textContent = '请求失败: ' + error.message;
                    statusMessage.className = 'status-message error';
                    statusMessage.style.display = 'block';
                } finally {
                    saveBtn.textContent = '保存并应用新规则';
                    saveBtn.disabled = false;
                    setTimeout(() => { statusMessage.style.display = 'none'; }, 3000);
                }
            });
        });
    </script>
</body>
</html>